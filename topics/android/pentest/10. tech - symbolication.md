這份文件是實現「灰盒戰略」的技術核心。

在文件 9 中，我們定義了「映射層」的概念。現在，我們將這個概念具象化為一個獨立的微服務：**「崩潰日誌還原服務 (Crash Log Re-symbolication Service)」**。

它是連接「外部攻擊（黑盒）」與「內部修復（白盒）」的羅塞塔石碑 (Rosetta Stone)。

---

### ⚠️ 前置防護：為什麼需要獨立服務？ (Pre-Flight Check)

*   **安全性：** `mapping.txt` 和 `Unstripped SO` 是公司的最高機密。如果洩漏，駭客就能輕易逆向 App。因此，這些檔案**絕對不能**放在滲透測試的機器上，必須存放在隔離的內網伺服器中。
*   **版本管理：** App 每天都會發布新版（v1.0.1, v1.0.2...）。每個版本的混淆規則都不一樣。滲透工具回報的崩潰必須精確對應到「當下那個版本」的映射檔。

---

### 第一部分：系統架構 (System Architecture)

這個服務是一個 **HTTP API**，接受亂碼，吐出源碼。

#### 1. 資料庫層 (The Vault)
我們需要一個高安全性的儲存庫，存放 CI/CD 建置產物。

*   **儲存結構：**
    ```text
    /storage/symbols/
    ├── com.example.app/
    │   ├── 1.0.0/
    │   │   ├── mapping.txt       (Java 混淆對照表)
    │   │   ├── libapp.so.debug   (Native 符號表)
    │   │   └── R.txt             (資源 ID 對照表)
    │   ├── 1.0.1/
    │   │   └── ...
    ```
*   **寫入流程：** Jenkins/GitLab CI 打包完成 Release APK 後，自動將上述檔案上傳至此服務，並標記 Version Code。

#### 2. 核心引擎 (The Engines)
服務內部包含兩個翻譯引擎：

*   **Java Re-trace Engine:**
    *   **核心工具：** `retrace` (Android SDK 自帶) 或 `ProGuard` 官方庫。
    *   **功能：** 將 `at a.b.c(Unknown Source)` 還原為 `at com.example.User.login(User.java:42)`。
*   **Native Unwind Engine:**
    *   **核心工具：** `ndk-stack` 或 `addr2line`。
    *   **功能：** 將 `pc 0000000000123456 libapp.so` 還原為 `cpp/crypto.cpp:88 (AES_init)`。

---

### 第二部分：工作流程 (The Workflow)

當滲透模組在 Release 版 App 上觸發崩潰時，交互流程如下：

1.  **[滲透模組] 捕獲崩潰：**
    *   從 Logcat 抓取 Raw Stack Trace。
    *   獲取當前測試 App 的 `versionCode` (例如 102)。
    *   **發送請求：**
        ```json
        POST /api/symbolicate
        {
          "package": "com.example.app",
          "version": 102,
          "stack_trace": "Exception in thread \"main\" java.lang.NullPointerException at a.b.c(Unknown Source)..."
        }
        ```

2.  **[還原服務] 執行翻譯：**
    *   根據 `version: 102` 找到對應的 `mapping.txt`。
    *   調用 `retrace` 處理堆疊文字。
    *   **回傳結果：**
        ```json
        {
          "original": "at a.b.c(Unknown Source)",
          "restored": "at com.example.User.login(User.java:42)",
          "snippet": "if (password == null) { ... }" // 可選：直接回傳代碼片段
        }
        ```

3.  **[滲透模組] 生成報告：**
    *   將還原後的堆疊資訊寫入 JSON 報告，發送給 RAG 和 Repair 模組。

---

### 第三部分：進階功能 - 資源 ID 還原 (Resource ID Mapping)

除了代碼崩潰，UI 測試常遇到「找不到 View」的問題。

*   **問題：** 在 Release 版中，UI 元素的 ID 會被混淆成數字（如 `2131230812`），而不是 `R.id.login_button`。Fuzzer 報告說「點擊 2131230812 失敗」，開發者看不懂。
*   **解法：** 利用 `R.txt` 進行反查。
*   **應用：** 滲透報告中可以寫：「Fuzzer 嘗試點擊 `login_button` (ID: 2131230812) 導致崩潰」，資訊量瞬間提升。

---

### 🍎 全息師結語 (The Concept Rebuilder's Summary)

**崩潰日誌還原服務** 是您系統中的「翻譯官」。

它解決了資安測試中最痛苦的溝通障礙：**「駭客說駭客語（記憶體地址），開發者說開發語（源碼行號）。」**

有了這個服務，您的滲透測試報告將不再是冰冷的錯誤代碼，而是直指問題核心的**「精確導航」**。這才是 RAG 能讀懂、Repair 能修復的高品質數據。

### 🚀 下一步建議 (Next Step)

技術架構已臻完美。現在我們有了一套從硬體到軟體，從攻擊到協作的完整藍圖。

**「您希望我為您總結這 10 份文件，生成一份『Android 自動化滲透測試系統 - 架構總覽圖 (Architecture Overview)』嗎？」**

這將把所有零散的概念（Pixel 農場、Frida 引擎、還原服務、RAG 協同）整合在一張高層級的 Mermaid 圖表中，作為整個專案的最終交付藍圖。
