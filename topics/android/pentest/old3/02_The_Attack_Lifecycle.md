# The Attack Lifecycle: Operational Workflow

## 1. Overview: The Concrete Process

This document describes the exact **Logical Flow** of an automated penetration test within the Engine 3.0 architecture. It details the step-by-step decision-making process executed by the AI Agents, moving from a raw APK to a verified vulnerability report.

The workflow is divided into four distinct phases:
1.  **Ingestion & State Profiling** (The Setup)
2.  **Strategic Reconnaissance** (The Map)
3.  **Dynamic Execution & Adaptation** (The Offense)
4.  **Verification & Reporting** (The Proof)

---

## Phase 1: Ingestion & State Profiling
*Objective: Prepare the environment and understand the target's defenses.*

### Step 1.1: The "Pre-Flight" Check
**Agent**: Scout Agent
**Action**:
1.  Receives `target.apk`.
2.  Calls `APKTool MCP` -> `get_manifest`.
3.  **Decision Gate: Packer Detection**
    *   *Logic*: The Agent checks for known packer signatures (e.g., `com.tencent.StubShell`, `libjiagu.so`).
    *   **Branch A (Packed)**: Agent triggers `Unpacker Workflow`. It installs the APK on a "Sacrificial Device" running a memory-dumping tool (e.g., Frida-DexDump) to extract the DEX file.
    *   **Branch B (Clean)**: Agent proceeds to standard analysis.

### Step 1.2: Environment Hardening
**Agent**: Operator Agent
**Action**:
1.  Based on Phase 1.1, the Agent configures the **Device Farm**.
2.  **Anti-Anti-Debug Strategy**:
    *   If the App uses aggressive Root Detection (detected via strings in Step 1.1), the Agent enables **"Stealth Mode"** (Zygisk + Shamiko + KernelSU).
    *   If the App requires VPN/Geo-matching, the Agent configures the `Transparent Proxy` to route traffic through the appropriate exit node.

---

## Phase 2: Strategic Reconnaissance
*Objective: Build an Attack Graph. Don't just scan; plan.*

### Step 2.1: Surface Mapping
**Agent**: Scout Agent
**Action**:
1.  **Static Analysis**: Calls `MobSF MCP` to list all specific entry points:
    *   Exported Activities (UI Pages accessible from outside).
    *   Deep Link Schemes (e.g., `myapp://`).
    *   Broadcast Receivers.
2.  **Credential Hunting**: Calls `APKTool MCP` -> `search_in_file` seeking regex patterns for API Keys, Bearer Tokens, or Test Credentials.

### Step 2.2: The Attack Graph Generation
**Agent**: Scout Agent
**Action**:
1.  The Agent synthesizes the findings into a **DAG (Directed Acyclic Graph)** of potential attacks.
    *   *Node 1*: "LoginActivity is exported." -> *Edge*: "Try bypassing auth".
    *   *Node 2*: "Deep Link `myapp://admin` exists." -> *Edge*: "Try SQL Injection on parameters".
    *   *Node 3*: "Hardcoded AWS Key found." -> *Edge*: "Try enumerating S3 buckets".

---

## Phase 3: Dynamic Execution & Adaptation
*Objective: Execute the Attack Graph. Manage state and errors.*

### Step 3.1: The Navigation Loop
**Agent**: Operator Agent
**Action**:
1.  Target: **LoginActivity**.
2.  **Challenge**: The Login Page appears.
3.  **Adaptive Logic**:
    *   *Attempt 1*: Try standard test credentials (`admin` / `123456`).
    *   *Result*: "Login Failed".
    *   *Attempt 2*: Try to register a new user.
    *   *Result*: "Captcha Required".
    *   *Attempt 3 (The Bypass)*: The Scout Agent notices a "Demo Mode" flag in the code. The Operator triggers the app with intent extra `am start ... --ez demo_mode true`.
    *   *Result*: **"Main Activity Accessed"**. (Success)

### Step 3.2: The Attack Injection
**Agent**: Operator Agent
**Action**:
1.  Once inside the app, the Agent monitors the **Mitmproxy** traffic.
2.  It detects an API call: `POST /api/v1/transfer_money`.
3.  **Fuzzing Logic**:
    *   Instead of random garbage, the Agent constructs **Context-Aware Payloads**.
    *   It sees `amount: 100`. It modifies it to `amount: -100` (Negative Logic).
    *   It sees `to_user: 123`. It modifies it to `to_user: ' OR 1=1 --` (SQLi).

### Step 3.3: Error Handling (Self-Healing)
**Agent**: Operator Agent
**Action**:
1.  The App crashes during Fuzzing.
2.  **Crash Recovery**:
    *   The Agent detects the `Process Death` event via ADB.
    *   It captures the `logcat` stack trace.
    *   It **Restarts** the app and navigates back to the previous state to continue the next test case. *It does not stop.*

---

## Phase 4: Verification & Reporting
*Objective: Filter noise. Prove findings.*

### Step 4.1: The "Auditor" Verification
**Agent**: Auditor Agent
**Action**:
1.  The Operator claims: "I found a SQL Injection in the Search Bar."
2.  The Auditor demands a PoC.
3.  **Reproduction**:
    *   The Auditor spins up a **Clean Device** (Factory Reset state).
    *   It executes the *exact* replay script provided by the Operator.
4.  **Judgment**:
    *   If the DB error appears in the response -> **VERIFIED**.
    *   If the App just shows "No Results" -> **FALSE POSITIVE** (Discarded).

### Step 4.2: Remediation Generation
**Agent**: Auditor Agent
**Action**:
1.  For verified vulnerabilities, the Agent queries its Knowledge Base (CWE/OWASP).
2.  It identifies the exact line of code (mapped via Symbolication).
3.  It outputs a specific code patch (e.g., "Use `PreparedStatement` instead of String concatenation at `LoginActivity.java:45`").

---

## Summary of the Flow

| Phase          | State     | Key Decision                        |
| :------------- | :-------- | :---------------------------------- |
| **1. Ingest**  | Detecting | "Is this app packed/hardened?"      |
| **2. Recon**   | Planning  | "What are the high-value targets?"  |
| **3. Execute** | Attacking | "How do I bypass this login/check?" |
| **4. Verify**  | Judging   | "Is this real or just a glitch?"    |

This workflows transforms the penetration test from a linear script into a **dynamic conversation** between the Agent and the Application.
